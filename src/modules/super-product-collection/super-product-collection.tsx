/*--------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * See License.txt in the project root for license information.
 *--------------------------------------------------------------*/

/* eslint-disable no-duplicate-imports */
import { IPriceComponentResources, ProductComponent } from '@msdyn365-commerce/components';
import * as Msdyn365 from '@msdyn365-commerce/core';
import { ProductPrice, ProductSearchResult } from '@msdyn365-commerce/retail-proxy';
import { ArrayExtensions, getPriceForProductSearchResult, ObjectExtensions, PriceForProductSearchResultInput } from '@msdyn365-commerce-modules/retail-actions';
import { getTelemetryObject, IComponentNodeProps, IModuleProps, INodeProps,
    ISingleSlideCarouselProps, ITelemetryContent, NodeTag, SingleSlideCarousel } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import * as React from 'react';

import { ISuperProductCollectionData } from './super-product-collection.data';
import { ISuperProductCollectionProps, layout } from './super-product-collection.props.autogenerated';

export interface IProductCollectionViewProps extends ISuperProductCollectionProps<ISuperProductCollectionData> {
    heading?: React.ReactNode;
    ProductCollectionContainer: IModuleProps;
    SingleSlideCarouselComponentProps: INodeProps;
    GridComponentProps: INodeProps;
    products: IProductComponentViewProps[];
    isCarousel: boolean;
    productPrices?: ProductPrice[];
}

export interface IProductComponentViewProps {
    ProductContainer: INodeProps;
    productComponent: React.ReactNode;
}
export interface IProductComponentState {
    products: ProductSearchResult[];
}

/**
 * ProductCollection component.
 */
class ProductCollection extends React.PureComponent<ISuperProductCollectionProps<ISuperProductCollectionData>, IProductComponentState> {
    private readonly telemetryContent: ITelemetryContent;

    private readonly productPrices: ProductPrice[];

    constructor(props: ISuperProductCollectionProps<ISuperProductCollectionData>) {
        super(props);
        this.productPrices = [];
        this.state = {
            products: this.props.config.productCollection.products
        };
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry);
    }

    public componentDidMount(): void {
        if (this.props.config.enableAffiliationBasedPricing &&
            this.props.context.actionContext.requestContext?.user?.isAuthenticated) {
            this._getActivePrice();
        }
    }

    public render(): JSX.Element | null {
        const { heading, className } = this.props.config;
        const { resources } = this.props;

        // Initiallize state in case if the products were not found during initial module render
        this.initProductState(this.props.config.productCollection);

        const products = this.state.products;
        const isCarousel = this.props.config.layout === layout.carousel;
        const headingLabel = heading ? heading.text : '';
        const headingComponent = heading && (
            <Msdyn365.Text
                className='ms-product-collection__heading'
                tag={heading.tag || 'h1'}
                text={headingLabel}
                editProps={{ onEdit: this.handleHeadingChange, requestContext: this.props.context.request }}
            />
        );

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- product check for safety.
        const updatedProducts = products?.map(
            (item: ProductSearchResult, index: number) => {
                const getProductData = this._getProduct(item, index);
                return !ObjectExtensions.isNullOrUndefined(getProductData) ? getProductData : undefined;
            }
        );

        const productCollectionViewProps = {
            ...this.props,
            heading: headingComponent,
            SingleSlideCarouselComponentProps: {
                tag: SingleSlideCarousel,
                className: '',
                flipperPrevLabel: `${headingLabel} ${resources.flipperPrevious}`,
                flipperNextLabel: `${headingLabel} ${resources.flipperNext}`,
                parentId: this.props.id,
                telemetryContent: this.telemetryContent
            } as IComponentNodeProps<ISingleSlideCarouselProps>,
            ProductCollectionContainer: {
                moduleProps: this.props,
                className: classnames('ms-product-collection', className)
            },
            GridComponentProps: {
                tag: 'ul' as NodeTag,
                className: 'ms-product-collection__items'
            },
            isCarousel,

            products: ArrayExtensions.hasElements(updatedProducts) && updatedProducts.filter(
                (item) => {
                    return item !== undefined;
                }
            ),
            productPrices: this.productPrices
        };
        return this.props.renderView(productCollectionViewProps) as React.ReactElement;
    }

    public handleHeadingChange = (event: Msdyn365.ContentEditableEvent) => this.props.config.heading!.text = event.target.value;

    /**
     * Helper method to initialize products state.
     * @param productCollection - List of products.
     */
    private readonly initProductState = (productCollection: Msdyn365.IProductList) => {
        if (!ArrayExtensions.hasElements(this.state.products) && ArrayExtensions.hasElements(productCollection.products)) {
            this.setState({ products: productCollection.products });
        }
    };

    private readonly _getProduct = (product: ProductSearchResult, index: number): IProductComponentViewProps | null => {
        if (!product || !product.Name) {
            this.props.telemetry.trace('[product-collection] Product or product name is null');
            return null;
        }
        const telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry);
        const { imageSettings, allowBackNavigation } = this.props.config;
        const resources = this.props.resources;
        const breaCrumbType = this.props.context.app.config.breadcrumbType;
        const allowBack = allowBackNavigation && (breaCrumbType === 'back' || breaCrumbType === 'categoryAndBack');
        const quickviewSlot = this.props.slots && this.props.slots.quickview && this.props.slots.quickview.length > 0 ? this.props.slots.quickview[0] : null;
        const reviewCount = 1;
        const reviewTotalRatings = Number(product.TotalRatings);
        const reviewCountAriaLabelValue = reviewTotalRatings > reviewCount ? resources.ratingCountAriaLabel : resources.ratingCountAriaLabelSingleUser;
        const isPriceMinMaxEnabled = this.props.data.featureState.result?.find(
            featureState => featureState.Name === 'Dynamics.AX.Application.RetailSearchPriceRangeFeature');
        const priceResources: IPriceComponentResources = {
            priceRangeSeparator: resources.priceRangeSeparator
        };
        return {
            ProductContainer: {
                tag: 'li' as NodeTag,
                className: 'ms-product-collection__item',
                role: 'listitem',
                key: index
            },
            productComponent: (
                <ProductComponent
                    context={this.props.context}
                    telemetryContent={telemetryContent}
                    imageSettings={imageSettings}
                    freePriceText={resources.priceFree}
                    originalPriceText={resources.originalPriceText}
                    currentPriceText={resources.currentPriceText}
                    ratingAriaLabel={resources.ratingAriaLabel}
                    ratingCountAriaLabel={reviewCountAriaLabelValue}
                    allowBack={allowBack}
                    id={this.props.id}
                    typeName={this.props.typeName}
                    data={{ product }}
                    quickViewButton={quickviewSlot}
                    isPriceMinMaxEnabled={isPriceMinMaxEnabled?.IsEnabled}
                    priceResources={priceResources}
                />
            )
        };
    };

    /**
     * Get the active price for products.
     */
    private readonly _getActivePrice = async (): Promise<void> => {
        const productsList = this.state.products;
        const products = await getPriceForProductSearchResult(
            new PriceForProductSearchResultInput(productsList),
            this.props.context.actionContext);

        this.setState({ products });
    };
}

export default ProductCollection;
