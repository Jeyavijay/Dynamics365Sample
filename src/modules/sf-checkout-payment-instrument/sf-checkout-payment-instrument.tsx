/*--------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * See License.txt in the project root for license information.
 *--------------------------------------------------------------*/

/* eslint-disable no-duplicate-imports */
import { AsyncResultStatus, getUrlSync } from '@msdyn365-commerce/core';
import { IGiftCardExtend } from '@msdyn365-commerce/global-state';
import { CardType } from '@msdyn365-commerce/retail-proxy';
import { retrieveCardPaymentAcceptResultAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { resolveCardTypesAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/StoreOperationsDataActions.g';
import {
    Address,
    CardPaymentAcceptResult,
    CartLine,
    TokenizedPaymentCard
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { IModuleProps, INodeProps, Modal } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import get from 'lodash/get';
import { action, computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { AsyncResultStatusCode } from '@msdyn365-commerce-modules/checkout';
import { AddPaymentFormComponent } from '@msdyn365-commerce-modules/checkout';
import { ErrorComponent } from '@msdyn365-commerce-modules/checkout';
import { Iframe } from '@msdyn365-commerce-modules/checkout';
import {
    paymentConnectorExtraContextMessage,
    PaymentConnectorPostMessageType,
    paymentConnectorSubmitMessage
} from '@msdyn365-commerce-modules/checkout';
import { WaitingComponent } from '@msdyn365-commerce-modules/checkout';
import { IVisibilityObserverProps, withVisibilityObserver } from '@msdyn365-commerce-modules/checkout';
import getCardPaymentAcceptPointAction, { GetCardPaymentAcceptPointInput } from './actions/get-card-payment-accept-point';
import { ISfCheckoutPaymentInstrumentData } from './sf-checkout-payment-instrument.data';
import { ISfCheckoutPaymentInstrumentProps } from './sf-checkout-payment-instrument.props.autogenerated';
import PaymentInformationComponent from './components/payment-information';

export interface ICheckoutPaymentInstrumentModuleProps
    extends ISfCheckoutPaymentInstrumentProps<ISfCheckoutPaymentInstrumentData>,
        IModuleStateProps,
        IVisibilityObserverProps {}

interface ICheckoutPaymentInstrumentState {
    errorMessage?: string;
    isFetchingPaymentConnector?: boolean;
    paymentConnectorHeight?: number;
    isPaymentVerificationRequried?: boolean;
    paymentVerificationPostData?: string;
    isPaymentProcessing?: boolean;
    isOverlayModal?: boolean;
}

export interface ICheckoutPaymentOverlayModal {
    modal: INodeProps;
}

export interface ICheckoutPaymentInstrumentViewProps extends ISfCheckoutPaymentInstrumentProps<{}>, ICheckoutPaymentInstrumentState {
    className?: string;
    checkoutPaymentInstrument: IModuleProps;
    waiting?: React.ReactNode;
    alert?: React.ReactNode;
    paymentInformation?: React.ReactNode;
    addPaymentForm?: React.ReactNode;
    overlayModal?: ICheckoutPaymentOverlayModal;
    isVisible?: boolean;
}

const zeroAmount = 0;

/**
 *
 * CheckoutPaymentInstrument component.
 * @extends {React.Component<ISfCheckoutPaymentInstrumentProps<ISfCheckoutPaymentInstrumentData>>}
 */
// @ts-expect-error
@withModuleState
@observer
export class CheckoutPaymentInstrument extends React.PureComponent<ICheckoutPaymentInstrumentModuleProps> {
    @computed get getLoyaltyAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.loyaltyAmount ? checkoutState.loyaltyAmount : 0;
    }

    @computed get getCustomerAccountAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        return checkoutState && checkoutState.customerAccountAmount ? checkoutState.customerAccountAmount : 0;
    }

    @computed get getGiftCardTotalAmount(): number {
        const checkoutState = this.props.data.checkout.result;
        if (!checkoutState || !checkoutState.giftCardExtends) {
            return 0;
        }
        return checkoutState.giftCardExtends.reduce((count: number, giftCard: IGiftCardExtend) => {
            const balance: number = giftCard.Balance || 0;
            return count + balance;
        }, 0);
    }

    @computed public get amountDue(): number {
        const {
            data: { checkout }
        } = this.props;
        if (!checkout.result) {
            return 0;
        }

        const checkoutResult = checkout.result;
        const cart = checkoutResult.checkoutCart.cart;
        if (!cart || !cart.CartLines || cart.CartLines.length === 0) {
            return 0;
        }

        // Use the card for payment after all other payment methods
        return (cart.TotalAmount || zeroAmount) - this.getGiftCardTotalAmount - this.getLoyaltyAmount - this.getCustomerAccountAmount;
    }

    @computed get shouldPaidByCard(): boolean {
        const {
            data: { checkout },
            config
        } = this.props;
        if (!checkout.result) {
            return false;
        }

        const checkoutResult = checkout.result;

        const { paymentTenderType, tokenizedPaymentCard } = checkoutResult;
        const isPaidByOtherPaymentSource = config.paymenTenderType !== paymentTenderType && tokenizedPaymentCard;

        return this.amountDue > zeroAmount && !isPaidByOtherPaymentSource;
    }

    @computed get isCartContainsItemsForShipping(): boolean {
        const pickupDeliveryModeCode = get(this.props, 'context.request.channel.PickupDeliveryModeCode');
        const emailDeliveryModeCode = get(this.props, 'context.request.channel.EmailDeliveryModeCode');
        const { channelDeliveryOptionConfig, featureState } = this.props.data;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const retailMultiplePickUpOptionEnabled = featureState?.result?.find(feature => feature.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;

        return retailMultiplePickUpOptionEnabled
            ? (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).some(
                  (cartLine: CartLine) =>
                      cartLine.DeliveryMode !==
                          channelDeliveryOptionConfig.result?.PickupDeliveryModeCodes?.find(
                              deliveryMode => deliveryMode === cartLine.DeliveryMode
                          ) && cartLine.DeliveryMode !== emailDeliveryModeCode
              )
            : (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).some(
                  (cartLine: CartLine) =>
                      cartLine.DeliveryMode !== pickupDeliveryModeCode && cartLine.DeliveryMode !== emailDeliveryModeCode
              );
    }

    @computed get isCartHasSelectedDeliveryMethods(): boolean {
        var deliveryModeSelcted: boolean = (get(this.props, 'data.checkout.result.checkoutCart.cart.CartLines') || []).every(
            (cartLine: CartLine) => !!cartLine.DeliveryMode
        );

        if (deliveryModeSelcted === true) {
            this.updatePaymentAcceptPageData();
        }

        return deliveryModeSelcted;
    }

    @computed get asyncResultStatus(): AsyncResultStatus | undefined {
        const isLoading = Object.values(this.props.data).some(data => get(data, 'status') === AsyncResultStatusCode.LOADING);
        if (isLoading) {
            return AsyncResultStatusCode.LOADING;
        }

        const isSuccess = Object.values(this.props.data).every(data => get(data, 'status') === AsyncResultStatusCode.SUCCESS);
        if (isSuccess) {
            return AsyncResultStatusCode.SUCCESS;
        }

        const isFailed = Object.values(this.props.data).some(data => get(data, 'status') === AsyncResultStatusCode.FAILED);
        if (isFailed) {
            return AsyncResultStatusCode.FAILED;
        }
        return;
    }

    @computed get hasSelectedItem(): boolean {
        return !!get(this.props.data, 'checkoutState.result.tokenizedPaymentCard');
    }

    @computed get isPaymentVerificationRedirection(): boolean {
        const { requestFormData, query } = this.props.context.request;
        return !!(requestFormData && query && query.pv === '1');
    }

    @computed get requestUrlOrigin(): string {
        const origin = get(window, 'location.origin');
        const requestUrl =
            typeof get(this.props, 'context.request.url.requestUrl') === 'string'
                ? new URL(get(this.props, 'context.request.url.requestUrl'))
                : get(this.props, 'context.request.url.requestUrl');
        return origin || requestUrl.origin;
    }

    public state: ICheckoutPaymentInstrumentState = {
        isFetchingPaymentConnector: true
    };

    private readonly moduleClassName: string = 'ms-checkout-payment-instrument';

    private readonly iframeRef: React.RefObject<Iframe> = React.createRef();

    public componentDidMount(): void {
        when(
            () => this.asyncResultStatus !== AsyncResultStatusCode.LOADING,
            () => {
                this.init();
            }
        );
        reaction(
            () => this.asyncResultStatus !== AsyncResultStatusCode.FAILED && this.shouldPaidByCard,
            () => {
                this.togglePayment();
            }
        );

        // Reaction for new checkout flow.
        if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout) {
            reaction(
                () => this.amountDue,
                () => {
                    if (
                        this.props.data.checkout.result?.shouldCollapsePaymentSection === false &&
                        this.amountDue > zeroAmount &&
                        !this.isPaymentVerificationRedirection
                    ) {
                        this.onEdit();
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.shouldCollapsePaymentSection,
                () => {
                    if (this.props.data.checkout.result?.shouldCollapsePaymentSection === false && !this.isPaymentVerificationRedirection) {
                        this.onEdit();
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.redirectAdditionalContext,
                () => {
                    if (this.props.config.isPrimaryPayment && this.props.data.checkout.result?.redirectAdditionalContext) {
                        this.handleAdditionalContext(this.props.data.checkout.result.redirectAdditionalContext);
                    }
                }
            );

            reaction(
                () => this.props.data.checkout.result?.isPlaceOrderEnabledInRedirection,
                () => {
                    if (this.props.config.isPrimaryPayment && this.props.data.checkout.result?.isPlaceOrderEnabledInRedirection) {
                        this.init();
                    }
                }
            );
        }
    }

    // eslint-disable-next-line complexity -- from existing code.
    public render(): JSX.Element | null {
        const {
            errorMessage,
            isFetchingPaymentConnector,
            paymentConnectorHeight,
            isPaymentVerificationRequried,
            isPaymentProcessing,
            isOverlayModal
        } = this.state;
        const {
            moduleState: { isReady, hasError, hasInitialized, isPending, hasExternalSubmitGroup },
            config: { iFrameHeightOverride, paymentStyleOverride, className, showBillingAddress, paymenTenderType },
            resources,
            data: { checkout, cardPaymentAcceptPoint },
            visibilityObserver
        } = this.props;

        const isVisible = visibilityObserver && visibilityObserver.isVisible;

        if (!hasInitialized || (this.asyncResultStatus !== AsyncResultStatusCode.FAILED && !this.shouldPaidByCard)) {
            this.props.context.telemetry.error('Checkout payment content is empty, module wont render');
            return null;
        }

        const { AcceptPageUrl, AcceptPageContent, MessageOrigin } = cardPaymentAcceptPoint.result ?? {
            AcceptPageUrl: undefined,
            AcceptPageContent: undefined,
            MessageOrigin: undefined
        };

        const { tokenizedPaymentCard, tenderLine, billingAddress } = checkout.result || {
            tokenizedPaymentCard: undefined,
            tenderLine: undefined,
            billingAddress: undefined
        };

        const paymentTenderTypeClassName = paymenTenderType ? `${this.moduleClassName}-${paymenTenderType.toLowerCase()}` : '';

        const isSinglePayment = checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout;

        const viewProps: ICheckoutPaymentInstrumentViewProps = {
            ...this.props,
            ...this.state,
            isVisible,
            className,

            checkoutPaymentInstrument: {
                moduleProps: this.props,
                className: classnames(this.moduleClassName, paymentTenderTypeClassName, className)
            },
            waiting: !isReady &&
                this.asyncResultStatus !== AsyncResultStatusCode.FAILED &&
                (this.asyncResultStatus === AsyncResultStatusCode.LOADING || isFetchingPaymentConnector || isPending) && (
                    <WaitingComponent {...{ message: resources.loadingMessage }} />
                ),
            alert: hasError && errorMessage && <ErrorComponent {...{ title: resources.errorMessageTitle, message: errorMessage }} />,
            paymentInformation: isReady && !isSinglePayment && !isPaymentVerificationRequried && !isPaymentProcessing && (
                <PaymentInformationComponent
                    tokenizedPaymentCard={tokenizedPaymentCard}
                    tenderLine={tenderLine}
                    billingAddress={showBillingAddress ? billingAddress : undefined}
                    canEdit={!hasExternalSubmitGroup}
                    onEdit={this.onEdit}
                    resources={resources}
                />
            ),
            addPaymentForm: (!isReady || isSinglePayment || isPaymentVerificationRequried) &&
                !isPaymentProcessing &&
                (AcceptPageUrl || AcceptPageContent) &&
                isVisible && (
                    <AddPaymentFormComponent
                        acceptPageUrl={AcceptPageUrl}
                        acceptPageContent={AcceptPageContent}
                        messageOrigin={MessageOrigin}
                        onSubmit={this.onSubmit}
                        onCancel={this.onCancel}
                        onIFrameMessage={this.onIFrameMessage}
                        iframeRef={this.iframeRef}
                        canSubmit={!hasExternalSubmitGroup}
                        canCancel={!hasExternalSubmitGroup && this.hasSelectedItem}
                        iFrameHeightOverride={iFrameHeightOverride || paymentConnectorHeight}
                        requestUrlOrigin={this.requestUrlOrigin}
                        isFetchingPaymentConnector={isFetchingPaymentConnector}
                        paymentStyleOverride={paymentStyleOverride}
                        resources={resources}
                    />
                ),
            overlayModal: {
                modal: {
                    tag: Modal,
                    className: `${this.moduleClassName}__overlay-modal`,
                    isOpen: isOverlayModal
                }
            }
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private readonly onIFrameMessage = async (event: MessageEvent): Promise<void> => {
        let result;
        try {
            if (typeof event.data !== 'string') {
                return;
            }
            result = JSON.parse(event.data);
        } catch (error) {
            //this.setTerminalError(error);
            return;
        }

        const shouldCheckConnectorId = this.props.config.shouldCheckConnectorId;

        const paymentConnectorId = this.props.data.cardPaymentAcceptPoint.result?.PaymentConnectorId;

        if (!result || !result.type || (shouldCheckConnectorId && result.id !== paymentConnectorId)) {
            return;
        }

        const { type, value } = result;

        switch (type) {
            case PaymentConnectorPostMessageType.Height:
                // The payment connector will post height after it completes initialization
                this.setState({
                    isFetchingPaymentConnector: false,
                    paymentConnectorHeight: value
                });
                return;
            case PaymentConnectorPostMessageType.Result:
                this.handlePaymentResult(value);
                return;
            case PaymentConnectorPostMessageType.CardPrefix:
                await this.handlePaymentCardPrefix(value);
                return;
            case PaymentConnectorPostMessageType.Error:
                this.handlePaymentError(value);
                return;
            case PaymentConnectorPostMessageType.Redirect:
                this.handlePaymentRedirect(value);
                return;
            case PaymentConnectorPostMessageType.Showoverlay:
                this.showOverlayModal(true);
                return;
            case PaymentConnectorPostMessageType.Hideoverlay:
                this.showOverlayModal(false);
                return;
            default:
                return;
            // Do nothing
        }
    };

    @action
    private readonly handlePaymentResult = (resultAccessCode: string, isRedirectedFromPaymentGateway: boolean = false): void => {
        const {
            data: { checkout, cardPaymentAcceptPoint },
            config: { isPrimaryPayment, paymenTenderType },
            resources: { termsAndConditionErrorMessage }
        } = this.props;

        const cartId = checkout.result?.checkoutCart.cart.Id || '';
        const paymentConnectorId = cardPaymentAcceptPoint.result?.PaymentConnectorId;

        const settings = {
            ReturnUrl: this.getReturnUrl(),
            ...(paymentConnectorId && { PaymentConnectorId: paymentConnectorId })
        };

        if (checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout) {
            const cardPaymentAcceptResult: CardPaymentAcceptResult = {
                AccessCode: resultAccessCode,
                Settings: settings
            };

            checkout.result
                .updateCardPaymentAcceptResult({ newCardPaymentAcceptResult: cardPaymentAcceptResult })
                .then(async () => {
                    if (!isPrimaryPayment) {
                        if (checkout.result?.isTermsAndConditionChecked || checkout.result?.isTermsAndConditionAccepted) {
                            this.props.moduleState.onSkip();
                            await checkout.result.updateIsPaymentSectionContainerReady({ newIsPaymentSectionContainerReady: true });
                        } else {
                            this.props.moduleState.setHasError(true);
                            this.setErrorMessage(termsAndConditionErrorMessage);
                        }
                    } else {
                        // In case of PSD2 redirect, cart we be updated in server side so refresh cart.
                        if (isRedirectedFromPaymentGateway) {
                            this.props.data.checkout.result?.checkoutCart.refreshCart({});
                        }

                        this.props.moduleState.setHasError(false);
                        this.props.moduleState.onReady();
                        this.setState({
                            terminalError: null,
                            errorMessage: null
                        });
                        this.props.moduleState.setIsSubmitContainer(true);

                        // For PSD2 redirect, place order
                        if (isRedirectedFromPaymentGateway) {
                            await checkout.result?.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: true });
                            await checkout.result?.updateIsPaymentSectionContainerReady({ newIsPaymentSectionContainerReady: true });
                        }
                    }
                })
                .catch(async (error: Error) => {
                    // IMPORTANT: Call RS for getting a new payment session. It should not re-use the previous session for the security reason.
                    await this.updatePaymentAcceptPageData();
                    this.setTerminalError(error);
                })
                .finally(() => {
                    this.setState({ isPaymentProcessing: false });
                });

            return;
        }

        retrieveCardPaymentAcceptResultAsync({ callerContext: this.props.context.actionContext }, resultAccessCode, [], cartId, settings)
            .then(async cardPaymentAcceptResult => {
                const { TenderLine, TokenizedPaymentCard, AdditionalContext } = cardPaymentAcceptResult || {};

                await this.saveBillingAddress(TokenizedPaymentCard);

                if (AdditionalContext) {
                    this.handleAdditionalContext(AdditionalContext);
                } else {
                    if (!TokenizedPaymentCard) {
                        this.setTerminalError(new Error('No TokenizedPaymentCard found'));
                        return;
                    }
                    const checkoutState = this.props.data.checkout.result;
                    if (checkoutState) {
                        // Try to update card prefix, if it is not set already.
                        // Adyen connector does not send msax-cc-cardprefix message
                        // but it sets the card prefix in tokenized card
                        if (!checkoutState.cardPrefix) {
                            const cardPrefix =
                                TokenizedPaymentCard &&
                                TokenizedPaymentCard.CardTokenInfo &&
                                TokenizedPaymentCard.CardTokenInfo.MaskedCardNumber;
                            if (cardPrefix) {
                                await checkoutState.updateCardPrefix({ newCardPrefix: cardPrefix });
                            }
                        }

                        if (!TokenizedPaymentCard.CardTypeId) {
                            const cardTypeId = await this.getCardTypeId(checkoutState.cardPrefix || '');
                            if (!cardTypeId) {
                                const error = new Error('The specified card type is not supported.');
                                error.name = 'CARDTYPENOTFOUND';
                                this.setTerminalError(error);
                                return;
                            }

                            TokenizedPaymentCard.CardTypeId = cardTypeId;
                        }

                        await checkoutState.updateTenderLine({ newTenderLine: TenderLine });
                        await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: TokenizedPaymentCard });
                        await checkoutState.updatePaymentTenderType({ newPaymentTenderType: paymenTenderType });

                        // In case of PSD2 redirect, cart we be updated in server side so refresh cart.
                        if (isRedirectedFromPaymentGateway) {
                            this.props.data.checkout.result?.checkoutCart.refreshCart({});
                        }

                        this.props.moduleState.setHasError(false);
                        this.props.moduleState.onReady();
                        this.setState({
                            terminalError: null,
                            errorMessage: null
                        });
                        this.props.moduleState.setIsSubmitContainer(true);
                    }
                }
            })
            .catch(error => {
                // IMPORTANT: Call RS for getting a new payment session. It should not re-use the previous session for the security reason.
                this.updatePaymentAcceptPageData();
                this.setTerminalError(error);
            })
            .finally(() => {
                this.setState({
                    isPaymentProcessing: false
                });
            });
    };

    @action
    private readonly handlePaymentCardPrefix = async (cardPrefix: string): Promise<void> => {
        const checkoutState = this.props.data.checkout.result;
        if (checkoutState) {
            await checkoutState.updateCardPrefix({ newCardPrefix: cardPrefix });
        }
    };

    @action
    private readonly handlePaymentRedirect = (redirectData: string): void => {
        this.setState({
            isPaymentVerificationRequried: true,
            paymentVerificationPostData: redirectData
        });
        this.props.moduleState.setHasError(false);
        this.props.moduleState.onReady();
    };

    private readonly showOverlayModal = (isShow: boolean): void => {
        this.setState({ isOverlayModal: isShow });
    };

    private readonly getCardTypeId = async (cardPrefix: string = ''): Promise<string | undefined> => {
        try {
            const response = await resolveCardTypesAsync({ callerContext: this.props.context.actionContext }, cardPrefix, CardType.Unknown);
            if (response && response.length > 0) {
                return response[0].TypeId;
            }
        } catch (error) {
            this.props.context.telemetry.error('Call to resolveCardTypesAsync failed.', error);
        }
        return undefined;
    };

    private readonly redirectToPaymentVerification = async (): Promise<void> => {
        const { isPaymentVerificationRequried, paymentVerificationPostData } = this.state;
        if (!isPaymentVerificationRequried || !paymentVerificationPostData) {
            return;
        }

        const checkoutState = this.props.data.checkout.result;
        if (checkoutState) {
            await checkoutState.updatePaymentTenderType({ newPaymentTenderType: this.props.config.paymenTenderType });
            await checkoutState.saveDataInStorage({});
            await checkoutState.updateIsPaymentVerificationRequired({ newIsPaymentVerificationRequired: true });
        }

        const redirectInfo = JSON.parse(paymentVerificationPostData);
        const { url, data } = redirectInfo;
        const form = document.createElement('form');

        form.method = 'POST';
        form.action = url;

        for (const propertyName of Object.keys(data)) {
            const element = document.createElement('input');
            element.name = propertyName;
            element.value = data[propertyName];
            form.appendChild(element);
        }

        document.body.appendChild(form);
        form.submit();
    };

    private readonly handlePaymentError = (value?: { Message: string }[]): void => {
        const {
            resources: { defaultSubmitErrorMessage = 'An error occurred in payment method details. Please try again.' }
        } = this.props;
        if (!value || value.length === 0) {
            // Fallback, if no message could be translated from payement accept page response
            this.setErrorMessage(defaultSubmitErrorMessage);
            return;
        }
        this.setErrorMessage(value.map((_value: { Message: string }) => _value.Message).join('\n'));
    };

    private readonly getReturnUrl = (): string => {
        let returnUrl = getUrlSync('checkout', this.props.context.actionContext) || '';

        const absoluteUrlRegExp = new RegExp('^(?:[a-z]+:)?//', 'i');
        const isAbsoluteUrl = absoluteUrlRegExp.test(returnUrl);
        if (window && !isAbsoluteUrl) {
            returnUrl = `${window.location.origin}${returnUrl}`;
        }

        return `${returnUrl}${!returnUrl.includes('?') ? '?' : '&'}pv=1`;
    };

    @action
    private readonly init = (): void => {
        this.props.moduleState.init({
            onEdit: this.onEdit,
            onCancel: this.onCancel,
            onSubmit: this.onSubmit,
            onContainerReady: this.onContainerReady,
            isCancellable: false,
            status: this.shouldPaidByCard ? 'updating' : 'disabled'
        });

        const {
            data: { checkout },
            config
        } = this.props;

        if (
            this.isPaymentVerificationRedirection &&
            !(checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && !checkout.result.isPlaceOrderEnabledInRedirection)
        ) {
            if (config.paymenTenderType === checkout.result?.paymentTenderType) {
                const { requestFormData } = this.props.context.request;

                const formData = btoa(JSON.stringify(requestFormData));

                this.setState({
                    isPaymentProcessing: true
                });

                this.props.moduleState.onPending();
                this.handlePaymentResult(formData, true);
            }
        } else if (this.asyncResultStatus === AsyncResultStatusCode.FAILED) {
            this.setState({
                isFetchingPaymentConnector: false
            });
            this.setTerminalError(new Error('Failed in load data'));
        }
    };

    @action
    private readonly setTerminalError = (terminalError: Error): void => {
        this.props.telemetry.exception(terminalError);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        const {
            resources: { genericErrorMessage, cardTypeErrorMessage }
        } = this.props;
        let errorMessage = genericErrorMessage;

        switch (terminalError.name) {
            case 'CARDTYPENOTFOUND': {
                errorMessage = cardTypeErrorMessage;
                break;
            }
            default:
        }

        this.setState({
            terminalError,
            errorMessage
        });
    };

    @action
    private readonly setErrorMessage = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.setState({
            errorMessage
        });
    };

    private readonly updatePaymentAcceptPageData = async (): Promise<void> => {
        const {
            context: { actionContext },
            config: { showBillingAddress, paymenTenderType },
            context: {
                request: { apiSettings }
            },
            data: { checkout }
        } = this.props;

        const input = {
            showBillingAddress,
            paymenTenderType,
            apiSettings,
            shouldEnableSinglePaymentAuthorizationCheckout: checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout,
            amountDue: this.amountDue
        };

        this.setState({
            isFetchingPaymentConnector: true
        });

        const checkoutState = checkout.result;
        if (checkoutState) {
            await checkoutState.updatePaymentTenderType({ newPaymentTenderType: undefined });
            await checkoutState.updateTenderLine({ newTenderLine: undefined });
            await checkoutState.updateTokenizedPaymentCard({ newTokenizedPaymentCard: undefined });
        }

        getCardPaymentAcceptPointAction(new GetCardPaymentAcceptPointInput(input), actionContext)
            .then(paymentAcceptPoint => {
                // In case, add form is not hidden. We need to explicty reset value to force re-rendering.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), { AcceptPageContent: '', AcceptPageUrl: '' });

                // IMPORTANT: Do NOT set isFetchingPaymentConnector = false in getCardPaymentAcceptPointAction success response.
                // The payment connector will post a message with content height when payment is ready.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), paymentAcceptPoint);
                this.setState({ paymentConnectorId: paymentAcceptPoint.PaymentConnectorId });

                // For new checkout flow, redirect additionContext comes from Checkout API exception and will be handled in below.
                if (checkoutState?.shouldEnableSinglePaymentAuthorizationCheckout && checkoutState.redirectAdditionalContext) {
                    this.handleAdditionalContext(checkoutState.redirectAdditionalContext);
                }
            })
            .catch((error: Error) => {
                this.setTerminalError(error);

                this.setState({
                    isFetchingPaymentConnector: false
                });

                // IMPORTANT: Clear the AcceptPageUrl and AcceptPageContent. It should not re-use the previous session for the security reason.
                actionContext.update(new GetCardPaymentAcceptPointInput(input), { AcceptPageContent: '', AcceptPageUrl: '' });
            });
    };

    private readonly postMessageToIframe = (message: object) => {
        const postMessage = get(this.iframeRef, 'current.postMessage');
        if (postMessage) {
            this.props.moduleState.onPending();
            postMessage(message);
        }
    };

    private readonly handleAdditionalContext = (additionalContext: string): void => {
        const message = paymentConnectorExtraContextMessage(additionalContext);
        this.postMessageToIframe(message);

        // eslint-disable-next-line no-console -- log the message for more information.
        console.log('Post payment connector extraContext message.');
    };

    private readonly saveBillingAddress = async (tokenizedPaymentCard?: TokenizedPaymentCard): Promise<void> => {
        const { showBillingAddress } = this.props.config;
        const checkoutState = this.props.data.checkout.result;

        // If we use billing address provided by adyen, billing address returned in TokenizedPaymentCard.
        if (checkoutState && showBillingAddress && tokenizedPaymentCard && tokenizedPaymentCard.Zip) {
            const billingAddress: Address = {
                ThreeLetterISORegionName: tokenizedPaymentCard.Country,
                Name: tokenizedPaymentCard.House === 'N/A' ? '' : tokenizedPaymentCard.House,
                Street: tokenizedPaymentCard.Address1,
                StreetNumber: tokenizedPaymentCard.Address2,
                City: tokenizedPaymentCard.City,
                State: tokenizedPaymentCard.State,
                ZipCode: tokenizedPaymentCard.Zip,
                Phone: tokenizedPaymentCard.Phone
            };
            await checkoutState.updateBillingAddress({ newBillingAddress: billingAddress });
        }
    };

    @action
    private readonly togglePayment = () => {
        if (this.shouldPaidByCard && this.props.moduleState.isDisabled) {
            this.props.moduleState.onUpdating();
        } else if (!this.shouldPaidByCard && !this.props.moduleState.isDisabled) {
            this.props.moduleState.setHasError(false);
            this.props.moduleState.onDisable();
        }
    };

    @action
    private readonly onSubmit = (): void => {
        const { isPrimaryPayment = true } = this.props.config;
        if (isPrimaryPayment) {
            this.postMessageToIframe(paymentConnectorSubmitMessage());
        } else {
            this.props.moduleState.onSkip();
        }
    };

    @action
    private readonly onCancel = (): void => {
        if (this.hasSelectedItem) {
            this.props.moduleState.onReady();
        } else {
            this.props.moduleState.onUpdating();
        }
    };

    @action
    private readonly onEdit = (): void => {
        this.props.moduleState.onUpdating();

        // IMPORTANT: Call RS for getting a new payment session. It should not re-use the previous session for the security reason.
        this.updatePaymentAcceptPageData();
    };

    @action
    private readonly onContainerReady = (): void => {
        this.redirectToPaymentVerification();
        this.props.moduleState.setIsSubmitContainer(false);
    };
}

export default withVisibilityObserver(CheckoutPaymentInstrument);
