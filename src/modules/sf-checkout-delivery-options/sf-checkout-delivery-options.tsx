/*--------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * See License.txt in the project root for license information.
 *--------------------------------------------------------------*/

/* eslint-disable no-duplicate-imports */
import { PriceComponent } from '@msdyn365-commerce/components';
import { ICheckoutState } from '@msdyn365-commerce/global-state';
import { Cart, ChannelDeliveryOptionConfiguration, FilterDeliveryModeOption } from '@msdyn365-commerce/retail-proxy';
import { getDeliveryOptionsAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { Address, CartLine, DeliveryOption } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { Button, getTelemetryObject, IModuleProps, INodeProps, ITelemetryContent, Waiting } from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import get from 'lodash/get';
import { action, computed, observable, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { ISfCheckoutDeliveryOptionsData } from './sf-checkout-delivery-options.data';
import {
    filterDeliveryModeOption,
    ISfCheckoutDeliveryOptionsProps,
    useDefaultDeliveryOption
} from './sf-checkout-delivery-options.props.autogenerated';
import DescriptionComponent from './components/sf-checkout-delivery-options.description';
import ErrorMessageComponent from './components/sf-checkout-delivery-options.error-message';
import ErrorTitleComponent from './components/sf-checkout-delivery-options.error-title';
import RadioButtonComponent from './components/sf-checkout-delivery-options.radio-button';

export interface ICheckoutDeliveryOptionsModuleProps
    extends ISfCheckoutDeliveryOptionsProps<ISfCheckoutDeliveryOptionsData>,
        IModuleStateProps {}

export interface ICheckoutDeliveryOption {
    DeliveryOption: INodeProps;
    description?: React.ReactNode;
    price?: React.ReactNode;
}

export interface ICheckoutDeliveryOptionEdit extends ICheckoutDeliveryOption {
    code: string;
    radioButton?: React.ReactNode;
}

export interface ICheckoutDeliveryOptionsList {
    DeliveryOptionsList: INodeProps;
    list: ICheckoutDeliveryOptionEdit[];
}

export interface ICheckoutDeliveryOptionsError {
    Error: INodeProps;
    title: React.ReactNode;
    message: React.ReactNode;
}

export interface ICheckoutDeliveryOptionsViewState {
    isLoading: boolean;
    isError: boolean;
    isShowList: boolean;
    isShowSelected: boolean;
    isShowSaveButton: boolean;
    isShowEditButton: boolean;
    isShowCancelButton: boolean;
}

export interface ICheckoutDeliveryOptionsViewProps extends ISfCheckoutDeliveryOptionsProps<{}> {
    CheckoutDeliveryOptions: IModuleProps;
    selectedItemId: string;
    deliveryOptionsData: DeliveryOption[];
    isLoading: boolean;
    errorMessageData: string;
    viewState: ICheckoutDeliveryOptionsViewState;
    deliveryOptions?: ICheckoutDeliveryOptionsList;
    deliveryOptionSelected?: ICheckoutDeliveryOption;
    errorMessage?: ICheckoutDeliveryOptionsError;
    waiting?: React.ReactNode;
    saveButton?: React.ReactNode;
    editButton?: React.ReactNode;
    cancelButton?: React.ReactNode;
    onDeliveryOptionChange(event: React.ChangeEvent<HTMLInputElement>): void;
    onSave(): void;
    onEdit(): void;
    onCancel(): void;
}

/**
 *
 * CheckoutDeliveryOptions component.
 * @extends {React.Component<ISfCheckoutDeliveryOptionsProps<ISfCheckoutDeliveryOptionsData>>}
 */
// @ts-expect-error
@withModuleState
@observer
class CheckoutDeliveryOptions extends React.Component<ICheckoutDeliveryOptionsModuleProps> {
    @observable private selectedItemId: string = '';

    @observable private deliveryOptions: DeliveryOption[] = [];

    @observable private isLoading: boolean = false;

    @observable private errorMessage?: string;

    @computed private get isDataReady(): boolean {
        return (this.props.data.checkout.result && this.props.data.checkout.status) === 'SUCCESS';
    }

    @computed private get isPaymentVerificationRedirection(): boolean {
        const { requestFormData, query } = this.props.context.request;
        return !!(requestFormData && query && query.pv === '1');
    }

    private cartDeliveryMode?: string;

    private retailMultiplePickUpOptionEnabled?: boolean = false;

    private channelDeliveryOptionConfig?: ChannelDeliveryOptionConfiguration;

    private readonly telemetryContent?: ITelemetryContent;

    private readonly isSelectDefaultOptionEnabled?: boolean;

    public constructor(props: ICheckoutDeliveryOptionsModuleProps) {
        super(props);
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
        this.isSelectDefaultOptionEnabled =
            this.props.config.useDefaultDeliveryOption && this.props.config.useDefaultDeliveryOption !== useDefaultDeliveryOption.none;
    }

    public async componentDidMount(): Promise<void> {
        when(
            () => this.isDataReady,
            async () => {
                await this.init();
            }
        );

        reaction(
            () => this.props.data.checkout.result && this.props.data.checkout.result.shippingAddress,
            async () => {
                await this.loadDeliveryOptions();
                this.props.moduleState.setIsCancellable(false);

                if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout) {
                    await this.props.data.checkout.result.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: true });
                }
            }
        );
    }

    public shouldComponentUpdate(nextProps: ICheckoutDeliveryOptionsModuleProps, nextState: ICheckoutDeliveryOptionsViewState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        if (!this.canShip()) {
            this.props.context.telemetry.error('Checkout delivery options content is empty, module wont render');
            return null;
        }

        const {
            moduleState: { isReady, isUpdating, hasError }
        } = this.props;
        const isError = !this.isLoading && hasError;
        const isShowList = !this.isLoading && !hasError && isUpdating && !this.isSelectDefaultOptionEnabled;
        const isShowSelected = !this.isLoading && !hasError && isReady;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        this.channelDeliveryOptionConfig = this.props.data.channelDeliveryOptionConfig?.result;
        this.retailMultiplePickUpOptionEnabled = this.props.data.featureState?.result?.find(
            feature => feature.Name === multiplePickupStoreSwitchName
        )?.IsEnabled;

        const { deliveryOptionAriaLabel } = this.props.resources;

        const viewProps = {
            ...this.props,
            onDeliveryOptionChange: this.onDeliveryOptionChange,
            selectedItemId: this.selectedItemId,
            deliveryOptionsData: this.deliveryOptions,
            isLoading: this.isLoading,
            errorMessageData: this.errorMessage,
            viewState: {
                isLoading: this.isLoading,
                isError,
                isShowList,
                isShowSelected,
                isShowSaveButton: isShowList && !this.props.moduleState.hasExternalSubmitGroup,
                isShowEditButton: isShowSelected && !this.props.moduleState.hasExternalSubmitGroup,
                isShowCancelButton: isShowList && !this.props.moduleState.hasExternalSubmitGroup && !!this.getSavedDeliveryOption()
            },
            CheckoutDeliveryOptions: {
                moduleProps: this.props,
                className: classname('ms-checkout-delivery-options', this.props.config.className)
            },
            deliveryOptions: {
                DeliveryOptionsList: {
                    className: 'ms-checkout-delivery-options__list',
                    role: 'list',
                    'aria-label': deliveryOptionAriaLabel
                },
                list: this.getDeliveryOptionList()
            },
            deliveryOptionSelected: this.getDeliveryOptionSelected(),
            errorMessage: this.getErrorMessage(),
            waiting: <Waiting />,
            saveButton: this.getSaveButton(),
            editButton: this.getEditButton(),
            cancelButton: this.getCancelButton(),
            onSave: this.onSave,
            onEdit: this.onEdit,
            onCancel: this.onCancel
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    @action
    private readonly init = async (): Promise<void> => {
        this.props.moduleState.init({
            onEdit: this.isSelectDefaultOptionEnabled ? undefined : this.onEdit,
            onCancel: this.isSelectDefaultOptionEnabled ? undefined : this.onCancel,
            onSubmit: this.isSelectDefaultOptionEnabled ? undefined : this.onSubmit,
            status:
                !(this.props.config.useDefaultDeliveryOption === useDefaultDeliveryOption.notDisplaySelectedDeliveryOption) &&
                this.canShip()
                    ? 'updating'
                    : 'disabled'
        });

        this.cartDeliveryMode = this.getSavedDeliveryOption();

        await this.loadDeliveryOptions();
    };

    private readonly canShip = (): boolean => {
        const hasInvoice = this.props.data.checkout.result?.checkoutCart.hasInvoiceLine;
        return !hasInvoice && this.getCartLinesForShipping().length > 0;
    };

    private readonly isDeliveryModeExists = (deliveryMode: string | undefined): boolean => {
        if (deliveryMode) {
            if (this.deliveryOptions.find(deliveryOption => deliveryOption.Code === deliveryMode)) {
                return true;
            }
        }
        return false;
    };

    private readonly getDeliveryOptionSelected = (): ICheckoutDeliveryOption | null => {
        const selectedItem = this.deliveryOptions.find(deliveryOption => deliveryOption.Code === this.selectedItemId);
        if (!selectedItem) {
            this.props.context.telemetry.error('Checkout delivery options content is empty, module wont render');
            return null;
        }

        const { id, typeName, context } = this.props;
        const { priceFree } = this.props.resources;
        const price = get(selectedItem, 'ShippingChargeAmount', 0);

        return {
            DeliveryOption: { className: 'ms-checkout-delivery-options__option-selected' },
            description: <DescriptionComponent {...{ description: selectedItem.Description }} />,
            price: (
                <PriceComponent
                    id={id}
                    typeName={typeName}
                    context={context}
                    className='ms-checkout-delivery-options__price'
                    data={{ price: { CustomerContextualPrice: price } }}
                    freePriceText={priceFree}
                />
            )
        };
    };

    private readonly getErrorMessage = (): ICheckoutDeliveryOptionsError => {
        const { errorMessageTitle } = this.props.resources;
        return {
            // @ts-expect-error
            CheckoutDeliveryOptionsError: { tag: 'span', className: 'ms-address-form__error', role: 'alert', 'aria-live': 'assertive' },
            title: <ErrorTitleComponent {...{ title: errorMessageTitle }} />,
            message: <ErrorMessageComponent {...{ message: this.errorMessage }} />
        };
    };

    private readonly getDeliveryOptionList = (): ICheckoutDeliveryOptionEdit[] => {
        const count = this.deliveryOptions.length;
        const { priceFree } = this.props.resources;
        const { id, typeName, context } = this.props;

        return this.deliveryOptions.map((deliveryOption: DeliveryOption, index: number) => {
            return {
                DeliveryOption: { className: 'ms-checkout-delivery-options__option', role: 'listitem' },
                code: deliveryOption.Code || '',
                radioButton: (
                    <RadioButtonComponent
                        {...{
                            isChecked: deliveryOption.Code === this.selectedItemId,
                            value: deliveryOption.Code,
                            ariaSetSize: count,
                            ariaPosInSet: index + 1,
                            ariaLabel: `${deliveryOption.Description!}`,
                            onChange: this.onDeliveryOptionChange,
                            telemetryContent: this.telemetryContent
                        }}
                    />
                ),
                description: (
                    <DescriptionComponent
                        {...{
                            description: deliveryOption.Description
                        }}
                    />
                ),
                price: (
                    <PriceComponent
                        id={id}
                        typeName={typeName}
                        context={context}
                        className='ms-checkout-delivery-options__price'
                        data={{ price: { CustomerContextualPrice: get(deliveryOption, 'ShippingChargeAmount', 0) } }}
                        freePriceText={priceFree}
                    />
                )
            };
        });
    };

    private readonly getSaveButton = (): React.ReactNode => {
        const { saveBtnLabel = 'Save' } = this.props.resources;
        return (
            <Button
                className='ms-checkout-delivery-options__btn-save'
                title={saveBtnLabel}
                color='primary'
                disabled={!this.selectedItemId}
                onClick={this.onSave}
            >
                {saveBtnLabel}
            </Button>
        );
    };

    private readonly getEditButton = (): React.ReactNode => {
        const { editBtnLabel = 'Change' } = this.props.resources;
        return (
            <Button className='ms-checkout-delivery-options__btn-edit' title={editBtnLabel} color='primary' onClick={this.onEdit}>
                {editBtnLabel}
            </Button>
        );
    };

    private readonly getCancelButton = (): React.ReactNode => {
        const { cancelBtnLabel = 'Cancel' } = this.props.resources;
        return (
            <Button className='ms-checkout-delivery-options__btn-cancel' title={cancelBtnLabel} color='secondary' onClick={this.onCancel}>
                {cancelBtnLabel}
            </Button>
        );
    };

    private readonly setError = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.errorMessage = errorMessage;
    };

    private readonly clearError = (): void => {
        this.props.moduleState.setHasError(false);
        this.errorMessage = undefined;
    };

    private readonly onSave = async (): Promise<void> => {
        await this.onSubmit();
    };

    private readonly onEdit = async (): Promise<void> => {
        this.onUpdating();

        if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout) {
            await this.props.data.checkout.result.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: true });
        }
    };

    private readonly onSubmit = async (): Promise<void> => {
        await this.updateCartDeliverySpecification(this.selectedItemId);

        if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout) {
            await this.props.data.checkout.result.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: false });
            await this.props.data.checkout.result.updateShouldCollapsePaymentSection({
                newShouldCollapsePaymentSection: false
            });

            if (this.selectedItemId === 'EC0002') {
                var vCodLoader = document.getElementById('iLoadingOverlay');
                if (vCodLoader) {
                    vCodLoader.style.display = 'block';
                }
                this.fnTriggerPaymentMethod();
            }
        }
    };

    private readonly onCancel = async (): Promise<void> => {
        // Reset to the saved value
        const savedDeliveryOption = this.getSavedDeliveryOption();
        if (savedDeliveryOption) {
            this.selectedItemId = savedDeliveryOption;
            this.onReady();

            if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout) {
                await this.props.data.checkout.result.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: false });
            }
        } else {
            this.onUpdating();
        }
    };

    private readonly getSavedDeliveryOption = (): string | undefined => {
        const cartLinesForShipping = this.getCartLinesForShipping();
        return cartLinesForShipping[0] && cartLinesForShipping[0].DeliveryMode;
    };

    private readonly updateCartDeliverySpecification = async (deliveryModeId: string): Promise<void> => {
        if (deliveryModeId.trim() === '') {
            return;
        }

        const { resources } = this.props;
        const checkoutState = this.props.data.checkout.result as ICheckoutState;
        const updateCartDeliverySpecificationInput = {
            deliveryModeId,
            shippingAddress: checkoutState.shippingAddress,
            channelDeliveryOptionConfig: this.retailMultiplePickUpOptionEnabled ? this.channelDeliveryOptionConfig : undefined
        };

        this.clearError();
        this.onPending();

        await checkoutState.checkoutCart
            .updateCartDeliverySpecification(updateCartDeliverySpecificationInput)
            .then(response => {
                if (response.status === 'FAILED') {
                    this.setError(resources.genericErrorMessage);
                } else {
                    this.onReady();
                    this.props.moduleState.setIsCancellable(true);
                }
            })
            .catch(() => {
                this.setError(resources.genericErrorMessage);
            });
    };

    private readonly getCartLinesForShipping = (): CartLine[] => {
        const { request } = this.props.context;
        const pickupDeliveryModeCode = request && request.channel && request.channel.PickupDeliveryModeCode;
        const emailDeliveryModeCode = request && request.channel && request.channel.EmailDeliveryModeCode;

        return this.retailMultiplePickUpOptionEnabled
            ? ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).filter(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !==
                            this.channelDeliveryOptionConfig?.PickupDeliveryModeCodes?.find(
                                deliveryMode => deliveryMode === cartLine.DeliveryMode
                            ) && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              )
            : ((this.props.data.checkout.result && this.props.data.checkout.result.checkoutCart.cart.CartLines) || []).filter(cartLine =>
                  cartLine.DeliveryMode && cartLine.DeliveryMode !== ''
                      ? cartLine.DeliveryMode !== pickupDeliveryModeCode && cartLine.DeliveryMode !== emailDeliveryModeCode
                      : cartLine
              );
    };

    private readonly getDeliveryOptions = async (shippingAddress: Address): Promise<void> => {
        if (!this.props.data.checkout.result) {
            return;
        }

        const { context, resources, config } = this.props;
        const cartState = this.props.data.checkout.result?.checkoutCart;
        const cartId = (cartState.cart as Cart).Id;

        if (context) {
            this.isLoading = true;
            this.deliveryOptions = [];
            this.selectedItemId = '';
            this.clearError();

            try {
                let originalDeliveryMode: string = '';
                const shippingCartLines = this.getCartLinesForShipping();
                const hasShippingDeliveryLines = shippingCartLines && shippingCartLines.length > 0 && shippingCartLines[0].DeliveryMode;
                if (hasShippingDeliveryLines) {
                    // First store the delivery mode, so that we can restore the shipping information.
                    originalDeliveryMode = shippingCartLines[0].DeliveryMode || '';

                    // Clear the delivery information on retail server, so GetDeliveryOptions charge calculation works correctly
                    const cart = cartState.cart;
                    await cartState.clearCartLinesDeliveryInformation({
                        cart,
                        channelDeliveryOptionConfiguration: this.channelDeliveryOptionConfig
                    });
                }

                // TODO: Check if we can move this getDeliveryOptions to checkout state
                let deliveryOptionFilter: FilterDeliveryModeOption;
                switch (config.filterDeliveryModeOption) {
                    case filterDeliveryModeOption.none:
                        deliveryOptionFilter = FilterDeliveryModeOption.None;
                        break;
                    case filterDeliveryModeOption.filterOutNonCarrierDeliveryMode:
                        deliveryOptionFilter = FilterDeliveryModeOption.FilterOutNonCarrierDeliveryMode;
                        break;
                    default:
                        deliveryOptionFilter = FilterDeliveryModeOption.FilterOutNonCarrierDeliveryMode;
                }
                const response = await getDeliveryOptionsAsync(
                    { callerContext: context.actionContext, queryResultSettings: {} },
                    cartId,
                    shippingAddress,
                    [],
                    deliveryOptionFilter,
                    true
                );

                if (hasShippingDeliveryLines) {
                    await this.updateCartDeliverySpecification(originalDeliveryMode);
                }

                if (response && response.length > 0) {
                    this.deliveryOptions = response;
                }
            } catch {
                this.setError(resources.genericErrorMessage);
            }

            if (this.deliveryOptions.length === 0) {
                this.setError(resources.deliveryOptionsNotFound);
            } else if (this.cartDeliveryMode && this.isDeliveryModeExists(this.cartDeliveryMode)) {
                this.selectedItemId = this.cartDeliveryMode;
                this.cartDeliveryMode = undefined;
                this.onReady();

                // For new checkout flow, when this module is ready, update the flag to call GetCardPaymentAcceptPoint with amountDue.
                if (
                    this.props.data.checkout.result.shouldEnableSinglePaymentAuthorizationCheckout &&
                    !this.isPaymentVerificationRedirection
                ) {
                    await this.props.data.checkout.result.updateShouldCollapsePaymentSection({ newShouldCollapsePaymentSection: false });
                }
            } else {
                this.onUpdating();
                this.selectedItemId = this.deliveryOptions.length > 0 ? this.deliveryOptions[0].Code || '' : ''; // By default, select first delivery
            }

            this.isLoading = false;
        }
    };

    private readonly loadDeliveryOptions = async (): Promise<void> => {
        const shippingAddress = this.props.data.checkout.result && this.props.data.checkout.result.shippingAddress;

        if (this.canShip() && shippingAddress) {
            await this.getDeliveryOptions(shippingAddress);

            if (this.isSelectDefaultOptionEnabled || this.props.data.checkout.result?.isExpressCheckoutApplied) {
                this.onSubmit();
            }
        }
    };

    private readonly onDeliveryOptionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const deliveryModeId = event.currentTarget.value;
        this.selectedItemId = deliveryModeId;
    };

    public fnGetCookie(cookieName: string) {
        let cookie = {};
        document.cookie.split(';').forEach(function(el) {
            let [key, value] = el.split('=');
            cookie[key.trim()] = value;
        });
        return cookie[cookieName];
    }

    public fnTriggerPaymentMethod = () => {
        const cCustomerGuestEmail = this.fnGetCookie('_msdyn365___guest_email');
        const cCheckoutCartId = this.fnGetCookie('_msdyn365___checkout_cart_');
        const cCartId = this.fnGetCookie('_msdyn365___cart_');

        const cRetailURL = this.props.context.request.apiSettings.baseUrl;
        const cRetailOUN = this.props.context.request.apiSettings.oun ? this.props.context.request.apiSettings.oun : '';
        const cCustomerSignedInEmail = this.props.context.request.user.emailAddress;
        const cCustomerEmailAddress = cCustomerGuestEmail ? cCustomerGuestEmail : cCustomerSignedInEmail;
        const cCustomerSignedIn = this.props.context.request.user.isAuthenticated;
        const cCustomerToken = this.props.context.request.user.token;

        const clearCartItems = (CartLineIds: any[]) => {
            var vCartId = decodeURI(cCartId);
            vCartId = vCartId.replace(/%3A/g, ':');
            var vCartIdResult = vCartId.slice(2);

            const cCartClearURL = `${cRetailURL}Commerce/Carts('${vCartIdResult}')/RemoveCartLines?api-version=7.3`;
            var data = JSON.stringify({ cartLineIds: CartLineIds });

            var xhr = new XMLHttpRequest();
            xhr.withCredentials = true;

            xhr.addEventListener('readystatechange', function() {
                try {
                    if (this.readyState === 4) {
                        if (xhr.status === 200) {
                            window.location.href = '/cash-on-delivery/thank-you?response=success';
                            console.log('CART CLEAR STATUS>>>>', xhr.status);
                            console.log('CART CLEAR RESPONSE>>>>', xhr.responseText);
                        } else {
                            window.location.href = '/cash-on-delivery/thank-you?response=failure';
                            console.log('CART CLEAR STATUS>>>>', xhr.status);
                            console.log('CART CLEAR RESPONSE>>>>', xhr.responseText);
                        }
                    }
                } catch (Exception) {
                    window.location.href = `/cash-on-delivery/thank-you?response=error&errorText=${Exception}`;
                }
            });

            xhr.open('POST', cCartClearURL);

            xhr.setRequestHeader('OUN', cRetailOUN);
            xhr.setRequestHeader('Content-Type', 'application/json');
            if (cCustomerSignedIn) {
                xhr.setRequestHeader('Authorization', `Bearer ${cCustomerToken}`);
            }

            xhr.send(data);
        };

        const getCartLineItems = () => {
            var vCartId = decodeURI(cCartId);
            vCartId = vCartId.replace(/%3A/g, ':');
            var vCartIdResult = vCartId.slice(2);

            const cCartLineItemURL = `${cRetailURL}Commerce/Carts('${vCartIdResult}')?api-version=7.3`;

            var xhr = new XMLHttpRequest();
            xhr.withCredentials = true;

            xhr.addEventListener('readystatechange', function() {
                try {
                    if (this.readyState === 4) {
                        if (xhr.status === 200) {
                            var response = JSON.parse(this.responseText);
                            var CartLineIds: any[] = [];
                            response.CartLines?.map((cart: { LineId: any }) => {
                                CartLineIds.push(cart.LineId);
                            });
                            clearCartItems(CartLineIds);
                            console.log('CART LINE ITEMS RESPOSNE IDs>>>', CartLineIds);
                        } else {
                            window.location.href = '/cash-on-delivery/thank-you?response=failure';
                            console.log(JSON.parse(this.responseText));
                        }
                    }
                } catch (Exception) {
                    window.location.href = `/cash-on-delivery/thank-you?response=error&errorText=${Exception}`;
                }
            });

            xhr.open('GET', cCartLineItemURL);
            xhr.setRequestHeader('OUN', cRetailOUN);
            if (cCustomerSignedIn) {
                xhr.setRequestHeader('Authorization', `Bearer ${cCustomerToken}`);
            }
            xhr.send();
        };

        const TCPLCheckOutWithCOD = () => {
            var vCartId = decodeURI(cCheckoutCartId);
            vCartId = vCartId.replace(/%3A/g, ':');
            var vCartIdResult = vCartId.slice(2);

            console.log('cCustomerGuestEmail', cCustomerGuestEmail);
            console.log('--------vCartIdDecode----------', vCartId);
            console.log('--------vCartIdResult----------', vCartIdResult);

            const cCashOnDeliveryURL = `${cRetailURL}Commerce/Carts('${vCartIdResult}')/TCPLCheckOutWithCOD?api-version=7.3`;

            var data = JSON.stringify({
                receiptEmail: cCustomerEmailAddress
            });

            var xhr = new XMLHttpRequest();
            xhr.withCredentials = true;

            xhr.addEventListener('readystatechange', function() {
                try {
                    if (this.readyState === 4) {
                        if (xhr.status === 200) {
                            var vCodResult = JSON.parse(xhr.responseText);
                            if (vCodResult.value) {
                                getCartLineItems();
                            } else {
                                window.location.href = '/cash-on-delivery/thank-you?response=failure';
                            }
                            console.log('COD API STATUS>>>>', xhr.status);
                            console.log('COD API RESPONSE>>>>', xhr.responseText);
                        } else {
                            window.location.href = '/cash-on-delivery/thank-you?response=failure';
                            console.log('COD API STATUS>>>>', xhr.status);
                            console.log('COD API RESPONSE>>>>', xhr.responseText);
                        }
                    }
                } catch (Exception) {
                    window.location.href = `/cash-on-delivery/thank-you?response=error&errorText=${Exception}`;
                }
            });

            xhr.open('POST', cCashOnDeliveryURL);
            xhr.setRequestHeader('User-Agent', 'Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0');
            xhr.setRequestHeader('OUN', cRetailOUN);
            xhr.setRequestHeader('Content-Type', 'application/json');
            if (cCustomerSignedIn) {
                xhr.setRequestHeader('Authorization', `Bearer ${cCustomerToken}`);
            }
            xhr.send(data);
        };

        TCPLCheckOutWithCOD();
    };

    private readonly onReady = () => {
        if (!(this.props.config.useDefaultDeliveryOption === useDefaultDeliveryOption.notDisplaySelectedDeliveryOption)) {
            this.props.moduleState.onReady();
        }
    };

    private readonly onUpdating = () => {
        if (!(this.props.config.useDefaultDeliveryOption === useDefaultDeliveryOption.notDisplaySelectedDeliveryOption)) {
            this.props.moduleState.onUpdating();
        }
    };

    private readonly onPending = () => {
        if (!this.isSelectDefaultOptionEnabled) {
            this.props.moduleState.onPending();
        }
    };
}

export default CheckoutDeliveryOptions;
